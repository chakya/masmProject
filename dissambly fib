//// stdio.h////      Copyright (c) Microsoft Corporation. All rights reserved.//// The C Standard Library <stdio.h> header.//#pragma once#define _INC_STDIO
#include <corecrt.h>#include <corecrt_wstdio.h>
_CRT_BEGIN_C_HEADER
/* Buffered I/O macros */
#define BUFSIZ  512

/* * Default number of supported streams. _NFILE is confusing and obsolete, but * supported anyway for backwards compatibility. */#define _NFILE      _NSTREAM_
#define _NSTREAM_   512
/* * Number of entries in _iob[] (declared below). Note that _NSTREAM_ must be * greater than or equal to _IOB_ENTRIES. */#define _IOB_ENTRIES 3
#define EOF    (-1)
#define _IOFBF 0x0000#define _IOLBF 0x0040#define _IONBF 0x0004

#define L_tmpnam   260 // _MAX_PATH#if __STDC_WANT_SECURE_LIB__    #define L_tmpnam_s L_tmpnam#endif

/* Seek method constants */
#define SEEK_CUR    1#define SEEK_END    2#define SEEK_SET    0
#define FILENAME_MAX    260#define FOPEN_MAX       20#define _SYS_OPEN       20#define TMP_MAX         _CRT_INT_MAX#if __STDC_WANT_SECURE_LIB__    #define TMP_MAX_S       TMP_MAX    #define _TMP_MAX_S      TMP_MAX#endif
typedef __int64 fpos_t;

#if _CRT_FUNCTIONS_REQUIRED
    _Check_return_opt_    _ACRTIMP errno_t __cdecl _get_stream_buffer_pointers(        _In_      FILE*   _Stream,        _Out_opt_ char*** _Base,        _Out_opt_ char*** _Pointer,        _Out_opt_ int**   _Count        );
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    //    // Narrow Character Stream I/O Functions    //    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    #if __STDC_WANT_SECURE_LIB__
        _Check_return_wat_        _ACRTIMP errno_t __cdecl clearerr_s(            _Inout_ FILE* _Stream            );
        _Check_return_wat_        _ACRTIMP errno_t __cdecl fopen_s(            _Outptr_result_maybenull_ FILE**      _Stream,            _In_z_                    char const* _FileName,            _In_z_                    char const* _Mode            );
        _Check_return_opt_        _Success_(return != 0)        _ACRTIMP size_t __cdecl fread_s(            _Out_writes_bytes_to_(_BufferSize, _ElementSize * _ElementCount)   void*  _Buffer,            _In_range_(>=, _ElementSize * _ElementCount)                       size_t _BufferSize,            _In_                                                               size_t _ElementSize,            _In_                                                               size_t _ElementCount,            _Inout_                                                            FILE*  _Stream            );
        _Check_return_wat_        _ACRTIMP errno_t __cdecl freopen_s(            _Outptr_result_maybenull_ FILE**      _Stream,            _In_z_                    char const* _FileName,            _In_z_                    char const* _Mode,            _Inout_                   FILE*       _OldStream            );
        _Success_(return != 0)        _ACRTIMP char* __cdecl gets_s(            _Out_writes_z_(_Size) char*   _Buffer,            _In_                  rsize_t _Size            );
        _Check_return_wat_        _ACRTIMP errno_t __cdecl tmpfile_s(            _Out_opt_ _Deref_post_valid_ FILE** _Stream            );
        _Success_(return == 0)        _Check_return_wat_        _ACRTIMP errno_t __cdecl tmpnam_s(            _Out_writes_z_(_Size) char*   _Buffer,            _In_                  rsize_t _Size            );
    #endif
    _ACRTIMP void __cdecl clearerr(        _Inout_ FILE* _Stream        );
    _Success_(return != -1)    _Check_return_opt_    _ACRTIMP int __cdecl fclose(        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _fcloseall(void);
    _Check_return_    _ACRTIMP FILE* __cdecl _fdopen(        _In_   int         _FileHandle,        _In_z_ char const* _Mode        );
    _Check_return_    _ACRTIMP int __cdecl feof(        _In_ FILE* _Stream        );
    _Check_return_    _ACRTIMP int __cdecl ferror(        _In_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl fflush(        _Inout_opt_ FILE* _Stream        );
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl fgetc(        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _fgetchar(void);
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl fgetpos(        _Inout_ FILE*   _Stream,        _Out_   fpos_t* _Position        );
    _Success_(return == _Buffer)    _Check_return_opt_    _ACRTIMP char* __cdecl fgets(        _Out_writes_z_(_MaxCount) char* _Buffer,        _In_                      int   _MaxCount,        _Inout_                   FILE* _Stream        );
    _Check_return_    _ACRTIMP int __cdecl _fileno(        _In_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _flushall(void);
    _Check_return_ _CRT_INSECURE_DEPRECATE(fopen_s)    _ACRTIMP FILE* __cdecl fopen(        _In_z_ char const* _FileName,        _In_z_ char const* _Mode        );
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl fputc(        _In_    int   _Character,        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _fputchar(        _In_ int _Character        );
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl fputs(        _In_z_  char const* _Buffer,        _Inout_ FILE*       _Stream        );
    _Check_return_opt_    _ACRTIMP size_t __cdecl fread(        _Out_writes_bytes_(_ElementSize * _ElementCount) void*  _Buffer,        _In_                                             size_t _ElementSize,        _In_                                             size_t _ElementCount,        _Inout_                                          FILE*  _Stream        );
    _Success_(return != 0)    _Check_return_ _CRT_INSECURE_DEPRECATE(freopen_s)    _ACRTIMP FILE* __cdecl freopen(        _In_z_  char const* _FileName,        _In_z_  char const* _Mode,        _Inout_ FILE*       _Stream        );
    _Check_return_    _ACRTIMP FILE* __cdecl _fsopen(        _In_z_ char const* _FileName,        _In_z_ char const* _Mode,        _In_   int         _ShFlag        );
    _Success_(return == 0)    _Check_return_opt_    _ACRTIMP int __cdecl fsetpos(        _Inout_ FILE*         _Stream,        _In_    fpos_t const* _Position        );
    _Success_(return == 0)    _Check_return_opt_    _ACRTIMP int __cdecl fseek(        _Inout_ FILE* _Stream,        _In_    long  _Offset,        _In_    int   _Origin        );
    _Success_(return == 0)    _Check_return_opt_    _ACRTIMP int __cdecl _fseeki64(        _Inout_ FILE*   _Stream,        _In_    __int64 _Offset,        _In_    int     _Origin        );
    _Success_(return != -1)    _Check_return_    _ACRTIMP long __cdecl ftell(        _Inout_ FILE* _Stream        );
    _Success_(return != -1)    _Check_return_    _ACRTIMP __int64 __cdecl _ftelli64(        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP size_t __cdecl fwrite(        _In_reads_bytes_(_ElementSize * _ElementCount) void const* _Buffer,        _In_                                           size_t      _ElementSize,        _In_                                           size_t      _ElementCount,        _Inout_                                        FILE*       _Stream        );
    _Success_(return != EOF)    _Check_return_    _ACRTIMP int __cdecl getc(        _Inout_ FILE* _Stream        );
    _Check_return_    _ACRTIMP int __cdecl getchar(void);
    _Check_return_    _ACRTIMP int __cdecl _getmaxstdio(void);
    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(        char*, gets_s,        char, _Buffer)
    _Check_return_    _ACRTIMP int __cdecl _getw(        _Inout_ FILE* _Stream        );
    _ACRTIMP void __cdecl perror(        _In_opt_z_ char const* _ErrorMessage        );
    #if defined _CRT_USE_WINAPI_FAMILY_DESKTOP_APP
        _Success_(return != -1)        _Check_return_opt_        _DCRTIMP int __cdecl _pclose(            _Inout_ FILE* _Stream            );
        _Check_return_        _DCRTIMP FILE* __cdecl _popen(            _In_z_ char const* _Command,            _In_z_ char const* _Mode            );
    #endif
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl putc(        _In_    int   _Character,        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl putchar(        _In_ int _Character        );
    _Check_return_opt_    _ACRTIMP int __cdecl puts(        _In_z_ char const* _Buffer        );
    _Success_(return != -1)    _Check_return_opt_    _ACRTIMP int __cdecl _putw(        _In_    int   _Word,        _Inout_ FILE* _Stream        );
    _ACRTIMP int __cdecl remove(        _In_z_ char const* _FileName        );
    _Check_return_    _ACRTIMP int __cdecl rename(        _In_z_ char const* _OldFileName,        _In_z_ char const* _NewFileName        );
    _ACRTIMP int __cdecl _unlink(        _In_z_ char const* _FileName        );
    #if _CRT_INTERNAL_NONSTDC_NAMES
        _CRT_NONSTDC_DEPRECATE(_unlink)        _ACRTIMP int __cdecl unlink(            _In_z_ char const* _FileName            );
    #endif
    _ACRTIMP void __cdecl rewind(        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _rmtmp(void);
    _CRT_INSECURE_DEPRECATE(setvbuf)    _ACRTIMP void __cdecl setbuf(        _Inout_                                             FILE* _Stream,        _Inout_updates_opt_(BUFSIZ) _Post_readable_size_(0) char* _Buffer        );
    _Check_return_opt_    _ACRTIMP int __cdecl _setmaxstdio(        _In_ int _Maximum        );
    _Success_(return == 0)    _Check_return_opt_    _ACRTIMP int __cdecl setvbuf(        _Inout_                      FILE*  _Stream,        _Inout_updates_opt_(_Size)   char*  _Buffer,        _In_                         int    _Mode,        _In_                         size_t _Size        );
    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC        #pragma push_macro("_tempnam")        #undef _tempnam    #endif
    _Check_return_    _ACRTIMP _CRTALLOCATOR char* __cdecl _tempnam(        _In_opt_z_ char const* _DirectoryName,        _In_opt_z_ char const* _FilePrefix        );
    #if defined _DEBUG && defined _CRTDBG_MAP_ALLOC        #pragma pop_macro("_tempnam")    #endif
    _Check_return_ _CRT_INSECURE_DEPRECATE(tmpfile_s)    _ACRTIMP FILE* __cdecl tmpfile(void);
    __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(        _Success_(return == 0)        errno_t, tmpnam_s,        _Always_(_Post_z_) char, _Buffer        )
#pragma warning(push)#pragma warning(disable: 28726) // __WARNING_BANNED_API_USAGEL2__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(        _Success_(return != 0)        char*, __RETURN_POLICY_DST, _ACRTIMP, tmpnam,        _Pre_maybenull_ _Always_(_Post_z_), char, _Buffer        )#pragma warning(pop)
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl ungetc(        _In_    int   _Character,        _Inout_ FILE* _Stream        );

    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    //    // I/O Synchronization and _nolock family of I/O functions    //    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    _ACRTIMP void __cdecl _lock_file(        _Inout_ FILE* _Stream        );
    _ACRTIMP void __cdecl _unlock_file(        _Inout_ FILE* _Stream        );
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl _fclose_nolock(        _Inout_ FILE* _Stream        );
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl _fflush_nolock(        _Inout_opt_ FILE* _Stream        );
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl _fgetc_nolock(        _Inout_ FILE* _Stream        );
    _Success_(return != EOF)    _Check_return_opt_    _ACRTIMP int __cdecl _fputc_nolock(        _In_    int   _Character,        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP size_t __cdecl _fread_nolock(        _Out_writes_bytes_(_ElementSize * _ElementCount) void*  _Buffer,        _In_                                             size_t _ElementSize,        _In_                                             size_t _ElementCount,        _Inout_                                          FILE*  _Stream        );
    _Check_return_opt_    _Success_(return != 0)    _ACRTIMP size_t __cdecl _fread_nolock_s(        _Out_writes_bytes_to_(_BufferSize, _ElementSize * _ElementCount) void*  _Buffer,        _In_range_(>=, _ElementSize * _ElementCount)                     size_t _BufferSize,        _In_                                                             size_t _ElementSize,        _In_                                                             size_t _ElementCount,        _Inout_                                                          FILE*  _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _fseek_nolock(        _Inout_ FILE* _Stream,        _In_    long  _Offset,        _In_    int   _Origin        );
    _Check_return_opt_    _ACRTIMP int __cdecl _fseeki64_nolock(        _Inout_ FILE*   _Stream,        _In_    __int64 _Offset,        _In_    int     _Origin        );
    _Check_return_    _ACRTIMP long __cdecl _ftell_nolock(        _Inout_ FILE* _Stream        );
    _Check_return_    _ACRTIMP __int64 __cdecl _ftelli64_nolock(        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP size_t __cdecl _fwrite_nolock(        _In_reads_bytes_(_ElementSize * _ElementCount) void const* _Buffer,        _In_                                           size_t      _ElementSize,        _In_                                           size_t      _ElementCount,        _Inout_                                        FILE*       _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _getc_nolock(        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _putc_nolock(        _In_    int   _Character,        _Inout_ FILE* _Stream        );
    _Check_return_opt_    _ACRTIMP int __cdecl _ungetc_nolock(        _In_    int   _Character,        _Inout_ FILE* _Stream        );
    #define _getchar_nolock()     _getc_nolock(stdin)    #define _putchar_nolock(_Ch)  _putc_nolock(_Ch, stdout)    #define _getwchar_nolock()    _getwc_nolock(stdin)    #define _putwchar_nolock(_Ch) _putwc_nolock(_Ch, stdout)

    #if defined _CRT_DISABLE_PERFCRIT_LOCKS && !defined _DLL        #define fclose(_Stream)                                           _fclose_nolock(_Stream)        #define fflush(_Stream)                                           _fflush_nolock(_Stream)        #define fgetc(_Stream)                                            _fgetc_nolock(_Stream)        #define fread(_DstBuf, _ElementSize, _Count, _Stream)             _fread_nolock(_DstBuf, _ElementSize, _Count, _Stream)        #define fread_s(_DstBuf, _DstSize, _ElementSize, _Count, _Stream) _fread_nolock_s(_DstBuf, _DstSize, _ElementSize, _Count, _Stream)        #define fseek(_Stream, _Offset, _Origin)                          _fseek_nolock(_Stream, _Offset, _Origin)        #define _fseeki64(_Stream, _Offset, _Origin)                      _fseeki64_nolock(_Stream, _Offset, _Origin)        #define ftell(_Stream)                                            _ftell_nolock(_Stream)        #define _ftelli64(_Stream)                                        _ftelli64_nolock(_Stream)        #define fwrite(_SrcBuf, _ElementSize, _Count, _Stream)            _fwrite_nolock(_SrcBuf, _ElementSize, _Count, _Stream)        #define getc(_Stream)                                             _getc_nolock(_Stream)        #define putc(_Ch, _Stream)                                        _fputc(_Ch, _Stream)        #define ungetc(_Ch, _Stream)                                      _ungetc_nolock(_Ch, _Stream)    #endif

    _ACRTIMP int* __cdecl __p__commode(void);
    #ifdef _CRT_DECLARE_GLOBAL_VARIABLES_DIRECTLY        extern int _commode;    #else        #define _commode (*__p__commode())    #endif

    // Variadic functions are not supported in managed code under /clr    #if defined _M_CEE_MIXED        #pragma managed(push, off)    #endif
    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    //    // Narrow Character Formatted Output Functions (Stream)    //    //-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    _ACRTIMP int __cdecl __stdio_common_vfprintf(        _In_                                    unsigned __int64 _Options,        _Inout_                                 FILE*            _Stream,        _In_z_ _Printf_format_string_params_(2) char const*      _Format,        _In_opt_                                _locale_t        _Locale,                                                va_list          _ArgList        );
    _ACRTIMP int __cdecl __stdio_common_vfprintf_s(        _In_                                    unsigned __int64 _Options,        _Inout_                                 FILE*            _Stream,        _In_z_ _Printf_format_string_params_(2) char const*      _Format,        _In_opt_                                _locale_t        _Locale,                                                va_list          _ArgList        );
    _Success_(return >= 0)    _ACRTIMP int __cdecl __stdio_common_vfprintf_p(        _In_                                    unsigned __int64 _Options,        _Inout_                                 FILE*            _Stream,        _In_z_ _Printf_format_string_params_(2) char const*      _Format,        _In_opt_                                _locale_t        _Locale,                                                va_list          _ArgList        );
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_l(        _Inout_  FILE*       const _Stream,        _In_z_   char const* const _Format,        _In_opt_ _locale_t   const _Locale,                 va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {00A8173B  push        edi  00A8173C  lea         edi,[ebp-0C0h]  00A81742  mov         ecx,30h  00A81747  mov         eax,0CCCCCCCCh  00A8174C  rep stos    dword ptr es:[edi]          return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);00A8174E  mov         esi,esp  00A81750  mov         eax,dword ptr [_ArgList]  00A81753  push        eax  00A81754  mov         ecx,dword ptr [_Locale]  00A81757  push        ecx  00A81758  mov         edx,dword ptr [_Format]  00A8175B  push        edx  00A8175C  mov         eax,dword ptr [_Stream]  00A8175F  push        eax  00A81760  call        ___local_stdio_printf_options (0A81334h)  00A81765  mov         ecx,dword ptr [eax+4]  00A81768  push        ecx  00A81769  mov         edx,dword ptr [eax]  00A8176B  push        edx  00A8176C  call        dword ptr [__imp____stdio_common_vfprintf (0A8B168h)]  00A81772  add         esp,18h  00A81775  cmp         esi,esp  00A81777  call        __RTC_CheckEsp (0A81118h)      }00A8177C  pop         edi  00A8177D  pop         esi  00A8177E  pop         ebx  00A8177F  add         esp,0C0h  00A81785  cmp         ebp,esp  00A81787  call        __RTC_CheckEsp (0A81118h)  00A8178C  mov         esp,ebp  00A8178E  pop         ebp  00A8178F  ret  --- No source file -------------------------------------------------------------00A81790  int         3  00A81791  int         3  00A81792  int         3  00A81793  int         3  00A81794  int         3  00A81795  int         3  00A81796  int         3  00A81797  int         3  00A81798  int         3  00A81799  int         3  00A8179A  int         3  00A8179B  int         3  00A8179C  int         3  00A8179D  int         3  00A8179E  int         3  00A8179F  int         3  00A817A0  int         3  00A817A1  int         3  00A817A2  int         3  00A817A3  int         3  00A817A4  int         3  00A817A5  int         3  00A817A6  int         3  00A817A7  int         3  00A817A8  int         3  00A817A9  int         3  00A817AA  int         3  00A817AB  int         3  00A817AC  int         3  00A817AD  int         3  00A817AE  int         3  00A817AF  int         3  --- c:\users\charles\documents\visual studio 2017\projects\consoleapplication1\consoleapplication1\consoleapplication1.cpp // ConsoleApplication1.cpp : Defines the entry point for the console application.//#include "stdafx.h"#include <stdio.h>
int main(void) {00A817B0  push        ebp  00A817B1  mov         ebp,esp  00A817B3  sub         esp,0D8h  00A817B9  push        ebx  00A817BA  push        esi  00A817BB  push        edi  00A817BC  lea         edi,[ebp-0D8h]  00A817C2  mov         ecx,36h  00A817C7  mov         eax,0CCCCCCCCh  00A817CC  rep stos    dword ptr es:[edi]   int sum = 0;00A817CE  mov         dword ptr [sum],0   for (int i = 0; i < 1000; i++) {00A817D5  mov         dword ptr [ebp-14h],0  00A817DC  jmp         main+37h (0A817E7h)  00A817DE  mov         eax,dword ptr [ebp-14h]  00A817E1  add         eax,1  00A817E4  mov         dword ptr [ebp-14h],eax  00A817E7  cmp         dword ptr [ebp-14h],3E8h  00A817EE  jge         main+69h (0A81819h)    if (i % 3 == 0 || i % 5 == 0) {00A817F0  mov         eax,dword ptr [ebp-14h]  00A817F3  cdq  00A817F4  mov         ecx,3  00A817F9  idiv        eax,ecx  00A817FB  test        edx,edx  00A817FD  je          main+5Eh (0A8180Eh)  00A817FF  mov         eax,dword ptr [ebp-14h]  00A81802  cdq    if (i % 3 == 0 || i % 5 == 0) {00A81803  mov         ecx,5  00A81808  idiv        eax,ecx  00A8180A  test        edx,edx  00A8180C  jne         main+67h (0A81817h)     sum += i;00A8180E  mov         eax,dword ptr [sum]  00A81811  add         eax,dword ptr [ebp-14h]  00A81814  mov         dword ptr [sum],eax    } }00A81817  jmp         main+2Eh (0A817DEh)   printf("%d", sum);00A81819  mov         eax,dword ptr [sum]  00A8181C  push        eax  00A8181D  push        offset string "%d" (0A87B30h)  00A81822  call        _printf (0A81320h)  00A81827  add         esp,8   return sum;00A8182A  mov         eax,dword ptr [sum]  }00A8182D  pop         edi  00A8182E  pop         esi  00A8182F  pop         ebx  00A81830  add         esp,0D8h  00A81836  cmp         ebp,esp  00A81838  call        __RTC_CheckEsp (0A81118h)  00A8183D  mov         esp,ebp  00A8183F  pop         ebp  00A81840  ret  --- No source file -------------------------------------------------------------00A81841  int         3  00A81842  int         3  00A81843  int         3  00A81844  int         3  00A81845  int         3  00A81846  int         3  00A81847  int         3  00A81848  int         3  00A81849  int         3  00A8184A  int         3  00A8184B  int         3  00A8184C  int         3  00A8184D  int         3  00A8184E  int         3  00A8184F  int         3  00A81850  int         3  00A81851  int         3  00A81852  int         3  00A81853  int         3  00A81854  int         3  00A81855  int         3  00A81856  int         3  00A81857  int         3  00A81858  int         3  00A81859  int         3  00A8185A  int         3  00A8185B  int         3  00A8185C  int         3  00A8185D  int         3  00A8185E  int         3  00A8185F  int         3  00A81860  int         3  00A81861  int         3  00A81862  int         3  00A81863  int         3  00A81864  int         3  00A81865  int         3  00A81866  int         3  00A81867  int         3  00A81868  int         3  00A81869  int         3  00A8186A  int         3  00A8186B  int         3  00A8186C  int         3  00A8186D  int         3  00A8186E  int         3  00A8186F  int         3  --- c:\program files (x86)\windows kits\10\include\10.0.15063.0\ucrt\stdio.h ---    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL vfprintf(        _Inout_                       FILE*       const _Stream,        _In_z_ _Printf_format_string_ char const* const _Format,                                      va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return _vfprintf_l(_Stream, _Format, NULL, _ArgList);    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_s_l(        _Inout_  FILE*       const _Stream,        _In_z_   char const* const _Format,        _In_opt_ _locale_t   const _Locale,                 va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return __stdio_common_vfprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);    }    #endif
    #if __STDC_WANT_SECURE_LIB__
        _Check_return_opt_        _CRT_STDIO_INLINE int __CRTDECL vfprintf_s(            _Inout_                       FILE*       const _Stream,            _In_z_ _Printf_format_string_ char const* const _Format,                                          va_list           _ArgList            )    #if defined _NO_CRT_STDIO_INLINE    ;    #else        {            return _vfprintf_s_l(_Stream, _Format, NULL, _ArgList);        }    #endif
    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_p_l(        _Inout_  FILE*       const _Stream,        _In_z_   char const* const _Format,        _In_opt_ _locale_t   const _Locale,                 va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return __stdio_common_vfprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vfprintf_p(        _Inout_                       FILE*       const _Stream,        _In_z_ _Printf_format_string_ char const* const _Format,                                      va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return _vfprintf_p_l(_Stream, _Format, NULL, _ArgList);    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vprintf_l(        _In_z_ _Printf_format_string_params_(2) char const* const _Format,        _In_opt_                                _locale_t   const _Locale,                                                va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return _vfprintf_l(stdout, _Format, _Locale, _ArgList);    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL vprintf(        _In_z_ _Printf_format_string_ char const* const _Format,                                      va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return _vfprintf_l(stdout, _Format, NULL, _ArgList);    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vprintf_s_l(        _In_z_ _Printf_format_string_params_(2) char const* const _Format,        _In_opt_                                _locale_t   const _Locale,                                                va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return _vfprintf_s_l(stdout, _Format, _Locale, _ArgList);    }    #endif
    #if __STDC_WANT_SECURE_LIB__
        _Check_return_opt_        _CRT_STDIO_INLINE int __CRTDECL vprintf_s(            _In_z_ _Printf_format_string_ char const* const _Format,                                          va_list           _ArgList            )    #if defined _NO_CRT_STDIO_INLINE    ;    #else        {            return _vfprintf_s_l(stdout, _Format, NULL, _ArgList);        }    #endif
    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vprintf_p_l(        _In_z_ _Printf_format_string_params_(2) char const* const _Format,        _In_opt_                                _locale_t   const _Locale,                                                va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return _vfprintf_p_l(stdout, _Format, _Locale, _ArgList);    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _vprintf_p(        _In_z_ _Printf_format_string_ char const* const _Format,                                      va_list           _ArgList        )    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        return _vfprintf_p_l(stdout, _Format, NULL, _ArgList);    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _fprintf_l(        _Inout_                                 FILE*       const _Stream,        _In_z_ _Printf_format_string_params_(0) char const* const _Format,        _In_opt_                                _locale_t   const _Locale,        ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        int _Result;        va_list _ArgList;        __crt_va_start(_ArgList, _Locale);        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);        __crt_va_end(_ArgList);        return _Result;    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL fprintf(        _Inout_                       FILE*       const _Stream,        _In_z_ _Printf_format_string_ char const* const _Format,        ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        int _Result;        va_list _ArgList;        __crt_va_start(_ArgList, _Format);        _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);        __crt_va_end(_ArgList);        return _Result;    }    #endif
    _ACRTIMP int __cdecl _set_printf_count_output(        _In_ int _Value        );
    _ACRTIMP int __cdecl _get_printf_count_output(void);
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _fprintf_s_l(        _Inout_                                 FILE*       const _Stream,        _In_z_ _Printf_format_string_params_(0) char const* const _Format,        _In_opt_                                _locale_t   const _Locale,        ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        int _Result;        va_list _ArgList;        __crt_va_start(_ArgList, _Locale);        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);        __crt_va_end(_ArgList);        return _Result;    }    #endif
    #if __STDC_WANT_SECURE_LIB__
        _Check_return_opt_        _CRT_STDIO_INLINE int __CRTDECL fprintf_s(            _Inout_                       FILE*       const _Stream,            _In_z_ _Printf_format_string_ char const* const _Format,            ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else        {            int _Result;            va_list _ArgList;            __crt_va_start(_ArgList, _Format);            _Result = _vfprintf_s_l(_Stream, _Format, NULL, _ArgList);            __crt_va_end(_ArgList);            return _Result;        }    #endif
    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _fprintf_p_l(        _Inout_                                 FILE*       const _Stream,        _In_z_ _Printf_format_string_params_(0) char const* const _Format,        _In_opt_                                _locale_t   const _Locale,        ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        int _Result;        va_list _ArgList;        __crt_va_start(_ArgList, _Locale);        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);        __crt_va_end(_ArgList);        return _Result;    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _fprintf_p(        _Inout_                       FILE*       const _Stream,        _In_z_ _Printf_format_string_ char const* const _Format,        ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        int _Result;        va_list _ArgList;        __crt_va_start(_ArgList, _Format);        _Result = _vfprintf_p_l(_Stream, _Format, NULL, _ArgList);        __crt_va_end(_ArgList);        return _Result;    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL _printf_l(        _In_z_ _Printf_format_string_params_(0) char const* const _Format,        _In_opt_                                _locale_t   const _Locale,        ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {        int _Result;        va_list _ArgList;        __crt_va_start(_ArgList, _Locale);        _Result = _vfprintf_l(stdout, _Format, _Locale, _ArgList);        __crt_va_end(_ArgList);        return _Result;    }    #endif
    _Check_return_opt_    _CRT_STDIO_INLINE int __CRTDECL printf(        _In_z_ _Printf_format_string_ char const* const _Format,        ...)    #if defined _NO_CRT_STDIO_INLINE    ;    #else    {00A81870  push        ebp  00A81871  mov         ebp,esp  00A81873  sub         esp,0D8h  00A81879  push        ebx  00A8187A  push        esi  00A8187B  push        edi  00A8187C  lea         edi,[ebp-0D8h]  00A81882  mov         ecx,36h  00A81887  mov         eax,0CCCCCCCCh  00A8188C  rep stos    dword ptr es:[edi]          int _Result;        va_list _ArgList;        __crt_va_start(_ArgList, _Format);00A8188E  call        __vcrt_va_start_verify_argument_type<char const * const> (0A811D1h)  00A81893  lea         eax,[ebp+0Ch]  00A81896  mov         dword ptr [_ArgList],eax          _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);00A81899  mov         eax,dword ptr [_ArgList]  00A8189C  push        eax  00A8189D  push        0  00A8189F  mov         ecx,dword ptr [_Format]  00A818A2  push        ecx  00A818A3  mov         esi,esp  00A818A5  push        1  00A818A7  call        dword ptr [__imp____acrt_iob_func (0A8B16Ch)]  00A818AD  add         esp,4  00A818B0  cmp         esi,esp  00A818B2  call        __RTC_CheckEsp (0A81118h)  00A818B7  push        eax  00A818B8  call        __vfprintf_l (0A81195h)  00A818BD  add         esp,10h  00A818C0  mov         dword ptr [_Result],eax          __crt_va_end(_ArgList);00A818C3  mov         dword ptr [_ArgList],0          return _Result;00A818CA  mov         eax,dword ptr [_Result]      }00A818CD  pop         edi  00A818CE  pop         esi  00A818CF  pop         ebx  00A818D0  add         esp,0D8h  00A818D6  cmp         ebp,esp  00A818D8  call        __RTC_CheckEsp (0A81118h)  00A818DD  mov         esp,ebp  00A818DF  pop         ebp  00A818E0  ret  --- No source file -------------------------------------------------------------00A818E1  int         3  00A818E2  int         3  00A818E3  int         3  00A818E4  int         3  00A818E5  int         3  00A818E6  int         3  00A818E7  int         3  00A818E8  int         3  00A818E9  int         3  00A818EA  int         3  00A818EB  int         3  00A818EC  int         3  00A818ED  int         3  00A818EE  int         3  00A818EF  int         3  00A818F0  int         3  00A818F1  int         3  00A818F2  int         3  00A818F3  int         3  00A818F4  int         3  00A818F5  int         3  00A818F6  int         3  00A818F7  int         3  00A818F8  int         3  00A818F9  int         3  00A818FA  int         3  00A818FB  int         3  00A818FC  int         3  00A818FD  int         3  00A818FE  int         3  00A818FF  int         3  @_RTC_AllocaHelper@12:00A81900  push        ebp  00A81901  mov         ebp,esp  00A81903  push        ebx  00A81904  push        esi  00A81905  mov         esi,ecx  00A81907  mov         ebx,edx  00A81909  test        esi,esi  00A8190B  je          _RTC_AllocaHelper+2Ch (0A8192Ch)  00A8190D  test        ebx,ebx  00A8190F  je          _RTC_AllocaHelper+2Ch (0A8192Ch)  00A81911  mov         edx,dword ptr [pAllocaInfoList]  00A81914  test        edx,edx  00A81916  je          _RTC_AllocaHelper+2Ch (0A8192Ch)  00A81918  push        edi  00A81919  mov         al,0CCh  00A8191B  mov         edi,esi  00A8191D  mov         ecx,ebx  00A8191F  rep stos    byte ptr es:[edi]  00A81921  mov         eax,dword ptr [edx]  00A81923  mov         dword ptr [esi+4],eax  00A81926  mov         dword ptr [esi+0Ch],ebx  00A81929  mov         dword ptr [edx],esi  00A8192B  pop         edi  00A8192C  pop         esi  00A8192D  pop         ebx  00A8192E  pop         ebp  00A8192F  ret         4  00A81932  int         3  00A81933  int         3  00A81934  int         3  00A81935  int         3  00A81936  int         3  00A81937  int         3  00A81938  int         3  00A81939  int         3  00A8193A  int         3  00A8193B  int         3  00A8193C  int         3  00A8193D  int         3  00A8193E  int         3  00A8193F  int         3  @_RTC_CheckStackVars2@12:00A81940  push        ebp  00A81941  mov         ebp,esp  00A81943  push        ecx  00A81944  push        ebx  00A81945  mov         ebx,edx  00A81947  mov         dword ptr [ebp-4],ecx  00A8194A  push        esi  00A8194B  push        edi  00A8194C  test        ebx,ebx  00A8194E  je          _RTC_CheckStackVars2+5Dh (0A8199Dh)  00A81950  xor         esi,esi  00A81952  cmp         dword ptr [ebx],esi  00A81954  jle         _RTC_CheckStackVars2+5Dh (0A8199Dh)  00A81956  xor         edi,edi  00A81958  jmp         _RTC_CheckStackVars2+20h (0A81960h)  00A8195A  lea         ebx,[ebx]  00A81960  mov         ecx,dword ptr [ebx+4]  00A81963  mov         eax,dword ptr [frame]  00A81966  mov         edx,dword ptr [ecx+edi]  00A81969  cmp         dword ptr [edx+eax-4],0CCCCCCCCh  00A81971  jne         _RTC_CheckStackVars2+45h (0A81985h)  00A81973  mov         eax,dword ptr [ecx+edi+4]  00A81977  add         eax,edx  00A81979  mov         edx,dword ptr [frame]  00A8197C  cmp         dword ptr [eax+edx],0CCCCCCCCh  00A81983  je          _RTC_CheckStackVars2+55h (0A81995h)  00A81985  push        dword ptr [ecx+edi+8]  00A81989  mov         eax,dword ptr [ebp+4]  00A8198C  push        eax  00A8198D  call        _RTC_StackFailure (0A810DCh)  00A81992  add         esp,8  00A81995  inc         esi  00A81996  add         edi,0Ch  00A81999  cmp         esi,dword ptr [ebx]  00A8199B  jl          _RTC_CheckStackVars2+20h (0A81960h)  00A8199D  mov         esi,dword ptr [allocaList]  00A819A0  xor         edi,edi  00A819A2  mov         eax,esi  00A819A4  test        esi,esi  00A819A6  je          _RTC_CheckStackVars2+0C8h (0A81A08h)  00A819A8  mov         eax,dword ptr [eax+4]  00A819AB  inc         edi  00A819AC  test        eax,eax  00A819AE  jne         _RTC_CheckStackVars2+68h (0A819A8h)  00A819B0  test        esi,esi  00A819B2  je          _RTC_CheckStackVars2+0C8h (0A81A08h)  00A819B4  cmp         dword ptr [esi],0CCCCCCCCh  00A819BA  jne         _RTC_CheckStackVars2+97h (0A819D7h)  00A819BC  cmp         dword ptr [esi+14h],0CCCCCCCCh  00A819C3  jne         _RTC_CheckStackVars2+97h (0A819D7h)  00A819C5  cmp         dword ptr [esi+18h],0CCCCCCCCh  00A819CC  jne         _RTC_CheckStackVars2+97h (0A819D7h)  00A819CE  cmp         dword ptr [esi+1Ch],0CCCCCCCCh  00A819D5  je          _RTC_CheckStackVars2+0A5h (0A819E5h)  00A819D7  mov         eax,dword ptr [ebp+4]  00A819DA  push        edi  00A819DB  push        esi  00A819DC  push        eax  00A819DD  call        _RTC_AllocaFailure (0A8108Ch)  00A819E2  add         esp,0Ch  00A819E5  mov         eax,dword ptr [esi+0Ch]  00A819E8  cmp         dword ptr [eax+esi-4],0CCCCCCCCh  00A819F0  je          _RTC_CheckStackVars2+0C0h (0A81A00h)  00A819F2  mov         eax,dword ptr [ebp+4]  00A819F5  push        edi  00A819F6  push        esi  00A819F7  push        eax  00A819F8  call        _RTC_AllocaFailure (0A8108Ch)  00A819FD  add         esp,0Ch  00A81A00  mov         esi,dword ptr [esi+4]  00A81A03  dec         edi  00A81A04  test        esi,esi  00A81A06  jne         _RTC_CheckStackVars2+74h (0A819B4h)  00A81A08  pop         edi  00A81A09  pop         esi  00A81A0A  pop         ebx  00A81A0B  mov         esp,ebp  00A81A0D  pop         ebp  00A81A0E  ret         4  00A81A11  int         3  00A81A12  int         3  00A81A13  int         3  00A81A14  int         3  00A81A15  int         3  00A81A16  int         3  00A81A17  int         3  00A81A18  int         3  00A81A19  int         3  00A81A1A  int         3  00A81A1B  int         3  00A81A1C  int         3  00A81A1D  int         3  00A81A1E  int         3  00A81A1F  int         3  00A81A20  int         3  00A81A21  int         3  00A81A22  int         3  00A81A23  int         3  00A81A24  int         3  00A81A25  int         3  00A81A26  int         3  00A81A27  int         3  00A81A28  int         3  00A81A29  int         3  00A81A2A  int         3  00A81A2B  int         3  00A81A2C  int         3  00A81A2D  int         3  00A81A2E  int         3  00A81A2F  int         3  00A81A30  int         3  00A81A31  int         3  00A81A32  int         3  00A81A33  int         3  00A81A34  int         3  00A81A35  int         3  00A81A36  int         3  00A81A37  int         3  00A81A38  int         3  00A81A39  int         3  00A81A3A  int         3  00A81A3B  int         3  00A81A3C  int         3  00A81A3D  int         3  00A81A3E  int         3  00A81A3F  int         3  00A81A40  int         3  00A81A41  int         3  00A81A42  int         3  00A81A43  int         3  00A81A44  int         3  00A81A45  int         3  00A81A46  int         3  00A81A47  int         3  00A81A48  int         3  00A81A49  int         3  00A81A4A  int         3  00A81A4B  int         3  00A81A4C  int         3  00A81A4D  int         3  00A81A4E  int         3  00A81A4F  int         3  @_RTC_CheckStackVars@8:00A81A50  push        ebp  00A81A51  mov         ebp,esp  00A81A53  push        ecx  00A81A54  push        ebx  00A81A55  mov         ebx,edx  00A81A57  mov         dword ptr [ebp-4],ecx  00A81A5A  push        esi  00A81A5B  xor         esi,esi  00A81A5D  cmp         dword ptr [ebx],esi  00A81A5F  jle         _RTC_CheckStackVars+52h (0A81AA2h)  00A81A61  push        edi  00A81A62  xor         edi,edi  00A81A64  mov         ecx,dword ptr [ebx+4]  00A81A67  mov         eax,dword ptr [frame]  00A81A6A  mov         edx,dword ptr [ecx+edi]  00A81A6D  cmp         dword ptr [edx+eax-4],0CCCCCCCCh  00A81A75  jne         _RTC_CheckStackVars+39h (0A81A89h)  00A81A77  mov         eax,dword ptr [ecx+edi+4]  00A81A7B  add         eax,edx  00A81A7D  mov         edx,dword ptr [frame]  00A81A80  cmp         dword ptr [eax+edx],0CCCCCCCCh  00A81A87  je          _RTC_CheckStackVars+49h (0A81A99h)  00A81A89  push        dword ptr [ecx+edi+8]  00A81A8D  mov         eax,dword ptr [ebp+4]  00A81A90  push        eax  00A81A91  call        _RTC_StackFailure (0A810DCh)  00A81A96  add         esp,8  00A81A99  inc         esi  00A81A9A  add         edi,0Ch  00A81A9D  cmp         esi,dword ptr [ebx]  00A81A9F  jl          _RTC_CheckStackVars+14h (0A81A64h)  00A81AA1  pop         edi  00A81AA2  pop         esi  00A81AA3  pop         ebx  00A81AA4  mov         esp,ebp  00A81AA6  pop         ebp  00A81AA7  ret  00A81AA8  int         3  00A81AA9  int         3  00A81AAA  int         3  00A81AAB  int         3  00A81AAC  int         3  00A81AAD  int         3  00A81AAE  int         3  00A81AAF  int         3  00A81AB0  int         3  00A81AB1  int         3  00A81AB2  int         3  00A81AB3  int         3  00A81AB4  int         3  00A81AB5  int         3  00A81AB6  int         3  00A81AB7  int         3  00A81AB8  int         3  00A81AB9  int         3  00A81ABA  int         3  00A81ABB  int         3  00A81ABC  int         3  00A81ABD  int         3  00A81ABE  int         3  00A81ABF  int         3  __RTC_CheckEsp:00A81AC0  bnd jne     esperror (0A81AC5h)  00A81AC3  bnd ret  esperror:00A81AC5  push        ebp  00A81AC6  mov         ebp,esp  00A81AC8  sub         esp,0  00A81ACB  push        eax  00A81ACC  bndstx      dword ptr [esp+eax],bnd0  00A81AD0  push        edx  00A81AD1  push        ebx  00A81AD2  push        esi  00A81AD3  push        edi  00A81AD4  mov         eax,dword ptr [ebp+4]  00A81AD7  push        0  00A81AD9  push        eax  00A81ADA  call        _RTC_Failure (0A8106Eh)  00A81ADF  add         esp,8  00A81AE2  pop         edi  00A81AE3  pop         esi  00A81AE4  pop         ebx  00A81AE5  pop         edx  00A81AE6  pop         eax  00A81AE7  bndldx      bnd0,dword ptr [esp+eax-4]  00A81AEC  mov         esp,ebp  00A81AEE  pop         ebp  00A81AEF  bnd ret  00A81AF1  int         3  00A81AF2  int         3  00A81AF3  int         3  00A81AF4  int         3  00A81AF5  int         3  00A81AF6  int         3  00A81AF7  int         3  00A81AF8  int         3  00A81AF9  int         3  00A81AFA  int         3  00A81AFB  int         3  00A81AFC  int         3  00A81AFD  int         3  00A81AFE  int         3  00A81AFF  int         3  00A81B00  mov         eax,offset __CrtDbgReport (0A810FFh)  00A81B05  ret  00A81B06  int         3  00A81B07  int         3  00A81B08  int         3  00A81B09  int         3  00A81B0A  int         3  00A81B0B  int         3  00A81B0C  int         3  00A81B0D  int         3  00A81B0E  int         3  00A81B0F  int         3  00A81B10  mov         eax,offset __CrtDbgReportW (0A81262h)  00A81B15  ret  00A81B16  int         3  00A81B17  int         3  00A81B18  int         3  00A81B19  int         3  00A81B1A  int         3  00A81B1B  int         3  00A81B1C  int         3  00A81B1D  int         3  00A81B1E  int         3  00A81B1F  int         3  00A81B20  cmp         byte ptr [init (0A8A148h)],0  00A81B27  jne         _RTC_InitBase+28h (0A81B48h)  00A81B29  push        0  00A81B2B  push        1  00A81B2D  push        0  00A81B2F  push        0  00A81B31  push        0  00A81B33  mov         byte ptr [init (0A8A148h)],1  00A81B3A  call        __CRT_RTC_INITW (0A8105Fh)  00A81B3F  push        eax  00A81B40  call        __RTC_SetErrorFuncW (0A811E5h)  00A81B45  add         esp,18h  00A81B48  ret  00A81B49  int         3  00A81B4A  int         3  00A81B4B  int         3  00A81B4C  int         3  00A81B4D  int         3  00A81B4E  int         3  00A81B4F  int         3  00A81B50  int         3  00A81B51  int         3  00A81B52  int         3  00A81B53  int         3  00A81B54  int         3  00A81B55  int         3  00A81B56  int         3  00A81B57  int         3  00A81B58  int         3  00A81B59  int         3  00A81B5A  int         3  00A81B5B  int         3  00A81B5C  int         3  00A81B5D  int         3  00A81B5E  int         3  00A81B5F  int         3  00A81B60  push        1  00A81B62  push        1  00A81B64  push        0  00A81B66  push        0  00A81B68  push        0  00A81B6A  call        __CRT_RTC_INITW (0A8105Fh)  00A81B6F  add         esp,14h  00A81B72  ret  00A81B73  int         3  00A81B74  int         3  00A81B75  int         3  00A81B76  int         3  00A81B77  int         3  00A81B78  int         3  00A81B79  int         3  00A81B7A  int         3  00A81B7B  int         3  00A81B7C  int         3  00A81B7D  int         3  00A81B7E  int         3  00A81B7F  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------
#elif defined _SCRT_STARTUP_WMAIN
    using main_policy = __scrt_main_policy;    using argv_policy = __scrt_wide_argv_policy;
    static void __cdecl initialize_environment() throw()    {        _initialize_wide_environment();    }
    static int __cdecl invoke_main() throw()    {        return wmain(__argc, __wargv, _get_initial_wide_environment());    }
#elif defined _SCRT_STARTUP_WINMAIN
    using main_policy = __scrt_winmain_policy;    using argv_policy = __scrt_narrow_argv_policy;
    static void __cdecl initialize_environment() throw()    {        _initialize_narrow_environment();    }
    static int __cdecl invoke_main() throw()    {        return WinMain(            reinterpret_cast<HINSTANCE>(&__ImageBase),            nullptr,            _get_narrow_winmain_command_line(),            __scrt_get_show_window_mode());    }
#elif defined _SCRT_STARTUP_WWINMAIN
    using main_policy = __scrt_winmain_policy;    using argv_policy = __scrt_wide_argv_policy;
    static void __cdecl initialize_environment() throw()    {        _initialize_wide_environment();    }
    static int __cdecl invoke_main() throw()    {        return wWinMain(            reinterpret_cast<HINSTANCE>(&__ImageBase),            nullptr,            _get_wide_winmain_command_line(),            __scrt_get_show_window_mode());    }
#endif
static int __cdecl pre_c_initialization() throw(){00A81B80  push        ebp  00A81B81  mov         ebp,esp  00A81B83  push        esi      _set_app_type(main_policy::get_app_type());00A81B84  call        __scrt_main_policy::get_app_type (0A810AFh)  00A81B89  push        eax  00A81B8A  call        __set_app_type (0A811BDh)  00A81B8F  add         esp,4  
    _set_fmode(_get_startup_file_mode());00A81B92  call        __get_startup_file_mode (0A8133Eh)  00A81B97  push        eax  00A81B98  call        __set_fmode (0A810F0h)  00A81B9D  add         esp,4      _commode = _get_startup_commit_mode();00A81BA0  call        __get_startup_commit_mode (0A81078h)  00A81BA5  mov         esi,eax  00A81BA7  call        ___p__commode (0A81109h)  00A81BAC  mov         dword ptr [eax],esi  
    if (!__scrt_initialize_onexit_tables(__scrt_module_type::exe))00A81BAE  push        1  00A81BB0  call        ___scrt_initialize_onexit_tables (0A81221h)  00A81BB5  add         esp,4  00A81BB8  movzx       eax,al  00A81BBB  test        eax,eax  00A81BBD  jne         pre_c_initialization+46h (0A81BC6h)          __scrt_fastfail(FAST_FAIL_FATAL_APP_EXIT);00A81BBF  push        7  00A81BC1  call        ___scrt_fastfail (0A81064h)  
    #ifdef _M_IX86    // Clear the x87 exception flags.  Any other floating point initialization    // should already have taken place before this function is called.    _asm { fnclex }00A81BC6  fnclex      #endif
    #ifdef _RTC    _RTC_Initialize();00A81BC8  call        __RTC_Initialize (0A810D7h)      atexit(_RTC_Terminate);00A81BCD  push        offset __RTC_Terminate (0A81172h)  00A81BD2  call        _atexit (0A810B4h)  00A81BD7  add         esp,4      #endif
    if (argv_policy::configure_argv() != 0)00A81BDA  call        __scrt_narrow_argv_policy::configure_argv (0A81244h)  00A81BDF  test        eax,eax  00A81BE1  je          pre_c_initialization+6Ah (0A81BEAh)          __scrt_fastfail(FAST_FAIL_FATAL_APP_EXIT);00A81BE3  push        7  00A81BE5  call        ___scrt_fastfail (0A81064h)  
    __scrt_initialize_type_info();00A81BEA  call        __scrt_initialize_type_info (0A81208h)  
    // If the user provided a _matherr handler, register it with the Universal    // CRT.  Windows OS components cannot set a custom matherr handler (this is    // a policy decision, to reduce complexity).    #ifndef _CRT_WINDOWS    if (__scrt_is_user_matherr_present())00A81BEF  call        ___scrt_is_user_matherr_present (0A8110Eh)  00A81BF4  test        eax,eax  00A81BF6  je          pre_c_initialization+85h (0A81C05h)      {        __setusermatherr(_matherr);00A81BF8  push        offset __matherr (0A81190h)  00A81BFD  call        ___setusermatherr (0A812DAh)  00A81C02  add         esp,4      }    #endif
    _initialize_invalid_parameter_handler();00A81C05  call        __initialize_invalid_parameter_handler (0A8117Ch)      _initialize_denormal_control();00A81C0A  call        __initialize_denormal_control (0A811D6h)  
    #ifdef _M_IX86    _initialize_default_precision();00A81C0F  call        __initialize_default_precision (0A81041h)      #endif
    _configthreadlocale(_get_startup_thread_locale_mode());00A81C14  call        __get_startup_thread_locale_mode (0A810A0h)  00A81C19  push        eax  00A81C1A  call        __configthreadlocale (0A8102Dh)  00A81C1F  add         esp,4  
    if (_should_initialize_environment())00A81C22  call        __should_initialize_environment (0A81352h)  00A81C27  movzx       ecx,al  00A81C2A  test        ecx,ecx  00A81C2C  je          pre_c_initialization+0B3h (0A81C33h)          initialize_environment();00A81C2E  call        initialize_environment (0A81F80h)  
    __scrt_initialize_winrt();00A81C33  call        ___scrt_initialize_winrt (0A81096h)  
    return 0;00A81C38  xor         eax,eax  }00A81C3A  pop         esi  00A81C3B  pop         ebp  00A81C3C  ret  --- No source file -------------------------------------------------------------00A81C3D  int         3  00A81C3E  int         3  00A81C3F  int         3  00A81C40  int         3  00A81C41  int         3  00A81C42  int         3  00A81C43  int         3  00A81C44  int         3  00A81C45  int         3  00A81C46  int         3  00A81C47  int         3  00A81C48  int         3  00A81C49  int         3  00A81C4A  int         3  00A81C4B  int         3  00A81C4C  int         3  00A81C4D  int         3  00A81C4E  int         3  00A81C4F  int         3  00A81C50  int         3  00A81C51  int         3  00A81C52  int         3  00A81C53  int         3  00A81C54  int         3  00A81C55  int         3  00A81C56  int         3  00A81C57  int         3  00A81C58  int         3  00A81C59  int         3  00A81C5A  int         3  00A81C5B  int         3  00A81C5C  int         3  00A81C5D  int         3  00A81C5E  int         3  00A81C5F  int         3  00A81C60  int         3  00A81C61  int         3  00A81C62  int         3  00A81C63  int         3  00A81C64  int         3  00A81C65  int         3  00A81C66  int         3  00A81C67  int         3  00A81C68  int         3  00A81C69  int         3  00A81C6A  int         3  00A81C6B  int         3  00A81C6C  int         3  00A81C6D  int         3  00A81C6E  int         3  00A81C6F  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------
static int __cdecl post_pgo_initialization() throw(){00A81C70  push        ebp  00A81C71  mov         ebp,esp      // This function calls the __local_stdio_{printf,scanf}_options() functions.    // These functions are defined in public headers with external linkage and    // thus may be PGO-instrumented.  We must not call these functions before the    // PGO instrumentation library is initialized.    __scrt_initialize_default_local_stdio_options();00A81C73  call        ___scrt_initialize_default_local_stdio_options (0A8123Fh)  
    return 0;00A81C78  xor         eax,eax  }00A81C7A  pop         ebp  00A81C7B  ret  --- No source file -------------------------------------------------------------00A81C7C  int         3  00A81C7D  int         3  00A81C7E  int         3  00A81C7F  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------
static void __cdecl pre_cpp_initialization() throw(){00A81C80  push        ebp  00A81C81  mov         ebp,esp      // Before we begin C++ initialization, set the unhandled exception    // filter so that unhandled C++ exceptions result in std::terminate    // being called:    __scrt_set_unhandled_exception_filter();00A81C83  call        ___scrt_set_unhandled_exception_filter (0A81159h)  
    _set_new_mode(_get_startup_new_mode());00A81C88  call        __get_startup_new_mode (0A811A4h)  00A81C8D  push        eax  00A81C8E  call        __set_new_mode (0A81186h)  00A81C93  add         esp,4  }00A81C96  pop         ebp  }00A81C97  ret  --- No source file -------------------------------------------------------------00A81C98  int         3  00A81C99  int         3  00A81C9A  int         3  00A81C9B  int         3  00A81C9C  int         3  00A81C9D  int         3  00A81C9E  int         3  00A81C9F  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------

// This is the common main implementation to which all of the CRT main functions// delegate (for executables; DLLs are handled separately).static __forceinline int __cdecl __scrt_common_main() throw(){00A81CA0  push        ebp  00A81CA1  mov         ebp,esp      // The /GS security cookie must be initialized before any exception handling    // targeting the current image is registered.  No function using exception    // handling can be called in the current image until after this call:    __security_init_cookie();00A81CA3  call        ___security_init_cookie (0A811F9h)  
    return __scrt_common_main_seh();00A81CA8  call        __scrt_common_main_seh (0A81CC0h)  }00A81CAD  pop         ebp  00A81CAE  ret  --- No source file -------------------------------------------------------------00A81CAF  int         3  00A81CB0  int         3  00A81CB1  int         3  00A81CB2  int         3  00A81CB3  int         3  00A81CB4  int         3  00A81CB5  int         3  00A81CB6  int         3  00A81CB7  int         3  00A81CB8  int         3  00A81CB9  int         3  00A81CBA  int         3  00A81CBB  int         3  00A81CBC  int         3  00A81CBD  int         3  00A81CBE  int         3  00A81CBF  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------
// When both the PGO instrumentation library and the CRT are statically linked,// PGO will initialize itself in XIAB.  We do most pre-C initialization before// PGO is initialized, but defer some initialization steps to after.  See the// commentary in post_pgo_initialization for details._CRTALLOC(".CRT$XIAA") static _PIFV pre_c_initializer    = pre_c_initialization;_CRTALLOC(".CRT$XIAC") static _PIFV post_pgo_initializer = post_pgo_initialization;_CRTALLOC(".CRT$XCAA") static _PVFV pre_cpp_initializer  = pre_cpp_initialization;

static __declspec(noinline) int __cdecl __scrt_common_main_seh() throw(){00A81CC0  push        ebp  00A81CC1  mov         ebp,esp  00A81CC3  push        0FFFFFFFEh  00A81CC5  push        0A88E98h  00A81CCA  push        offset _except_handler4 (0A83890h)  00A81CCF  mov         eax,dword ptr fs:[00000000h]  00A81CD5  push        eax  00A81CD6  add         esp,0FFFFFFD0h  00A81CD9  push        ebx  00A81CDA  push        esi  00A81CDB  push        edi  00A81CDC  mov         eax,dword ptr [__security_cookie (0A8A024h)]  00A81CE1  xor         dword ptr [ebp-8],eax  00A81CE4  xor         eax,ebp  00A81CE6  push        eax  00A81CE7  lea         eax,[ebp-10h]  00A81CEA  mov         dword ptr fs:[00000000h],eax  00A81CF0  mov         dword ptr [ebp-18h],esp      if (!__scrt_initialize_crt(__scrt_module_type::exe))00A81CF3  push        1  00A81CF5  call        ___scrt_initialize_crt (0A81280h)  00A81CFA  add         esp,4  00A81CFD  movzx       eax,al  00A81D00  test        eax,eax  00A81D02  jne         __scrt_common_main_seh+4Bh (0A81D0Bh)          __scrt_fastfail(FAST_FAIL_FATAL_APP_EXIT);00A81D04  push        7  00A81D06  call        ___scrt_fastfail (0A81064h)  
    bool has_cctor = false;00A81D0B  mov         byte ptr [has_cctor],0      __try00A81D0F  mov         dword ptr [ebp-4],0      {        bool const is_nested = __scrt_acquire_startup_lock();00A81D16  call        ___scrt_acquire_startup_lock (0A81311h)  00A81D1B  mov         byte ptr [ebp-1Ah],al  
        if (__scrt_current_native_startup_state == __scrt_native_startup_state::initializing)00A81D1E  cmp         dword ptr [__scrt_current_native_startup_state (0A8A158h)],1  00A81D25  jne         __scrt_common_main_seh+70h (0A81D30h)          {            __scrt_fastfail(FAST_FAIL_FATAL_APP_EXIT);00A81D27  push        7  00A81D29  call        ___scrt_fastfail (0A81064h)  00A81D2E  jmp         __scrt_common_main_seh+0D1h (0A81D91h)          }        else if (__scrt_current_native_startup_state == __scrt_native_startup_state::uninitialized)00A81D30  cmp         dword ptr [__scrt_current_native_startup_state (0A8A158h)],0  00A81D37  jne         __scrt_common_main_seh+0CDh (0A81D8Dh)          {            __scrt_current_native_startup_state = __scrt_native_startup_state::initializing;00A81D39  mov         dword ptr [__scrt_current_native_startup_state (0A8A158h)],1  
            if (_initterm_e(__xi_a, __xi_z) != 0)00A81D43  push        offset __xi_z (0A87618h)  00A81D48  push        offset __xi_a (0A8730Ch)  00A81D4D  call        __initterm_e (0A81091h)  00A81D52  add         esp,8  00A81D55  test        eax,eax  00A81D57  je          __scrt_common_main_seh+0AFh (0A81D6Fh)                  return 255;00A81D59  mov         dword ptr [ebp-38h],0FFh  00A81D60  mov         dword ptr [ebp-4],0FFFFFFFEh  00A81D67  mov         eax,dword ptr [ebp-38h]  00A81D6A  jmp         $LN18+44h (0A81EBBh)  
            _initterm(__xc_a, __xc_z);00A81D6F  push        offset __xc_z (0A87208h)  00A81D74  push        offset __xc_a (0A87000h)  00A81D79  call        __initterm (0A812D0h)  00A81D7E  add         esp,8  
            __scrt_current_native_startup_state = __scrt_native_startup_state::initialized;00A81D81  mov         dword ptr [__scrt_current_native_startup_state (0A8A158h)],2          }        else00A81D8B  jmp         __scrt_common_main_seh+0D1h (0A81D91h)          {            has_cctor = true;00A81D8D  mov         byte ptr [has_cctor],1          }
        __scrt_release_startup_lock(is_nested);00A81D91  movzx       ecx,byte ptr [ebp-1Ah]  00A81D95  push        ecx  00A81D96  call        ___scrt_release_startup_lock (0A81307h)  00A81D9B  add         esp,4  
        // If this module has any dynamically initialized __declspec(thread)        // variables, then we invoke their initialization for the primary thread        // used to start the process:        _tls_callback_type const* const tls_init_callback = __scrt_get_dyn_tls_init_callback();00A81D9E  call        ___scrt_get_dyn_tls_init_callback (0A81276h)  00A81DA3  mov         dword ptr [ebp-20h],eax          if (*tls_init_callback != nullptr && __scrt_is_nonwritable_in_current_image(tls_init_callback))00A81DA6  mov         edx,dword ptr [ebp-20h]  00A81DA9  cmp         dword ptr [edx],0  00A81DAC  je          __scrt_common_main_seh+11Ah (0A81DDAh)  00A81DAE  mov         eax,dword ptr [ebp-20h]  00A81DB1  push        eax  00A81DB2  call        ___scrt_is_nonwritable_in_current_image (0A8134Dh)  00A81DB7  add         esp,4  00A81DBA  movzx       ecx,al  00A81DBD  test        ecx,ecx  00A81DBF  je          __scrt_common_main_seh+11Ah (0A81DDAh)          {            (*tls_init_callback)(nullptr, DLL_THREAD_ATTACH, nullptr);00A81DC1  push        0  00A81DC3  push        2  00A81DC5  push        0  00A81DC7  mov         edx,dword ptr [ebp-20h]  00A81DCA  mov         eax,dword ptr [edx]  00A81DCC  mov         dword ptr [ebp-28h],eax  00A81DCF  mov         ecx,dword ptr [ebp-28h]  00A81DD2  call        @_guard_check_icall@4 (0A812C1h)  00A81DD7  call        dword ptr [ebp-28h]          }
        // If this module has any thread-local destructors, register the        // callback function with the Unified CRT to run on exit.        _tls_callback_type const * const tls_dtor_callback = __scrt_get_dyn_tls_dtor_callback();00A81DDA  call        ___scrt_get_dyn_tls_dtor_callback (0A810CDh)  00A81DDF  mov         dword ptr [ebp-24h],eax          if (*tls_dtor_callback != nullptr && __scrt_is_nonwritable_in_current_image(tls_dtor_callback))00A81DE2  mov         ecx,dword ptr [ebp-24h]  00A81DE5  cmp         dword ptr [ecx],0  00A81DE8  je          __scrt_common_main_seh+14Bh (0A81E0Bh)  00A81DEA  mov         edx,dword ptr [ebp-24h]  00A81DED  push        edx  00A81DEE  call        ___scrt_is_nonwritable_in_current_image (0A8134Dh)  00A81DF3  add         esp,4  00A81DF6  movzx       eax,al  00A81DF9  test        eax,eax  00A81DFB  je          __scrt_common_main_seh+14Bh (0A81E0Bh)          {            _register_thread_local_exe_atexit_callback(*tls_dtor_callback);00A81DFD  mov         ecx,dword ptr [ebp-24h]  00A81E00  mov         edx,dword ptr [ecx]  00A81E02  push        edx  00A81E03  call        __register_thread_local_exe_atexit_callback (0A811AEh)  00A81E08  add         esp,4          }
        //        // Initialization is complete; invoke main...        //
        int const main_result = invoke_main();00A81E0B  call        invoke_main (0A81F90h)  00A81E10  mov         dword ptr [ebp-2Ch],eax  
        //        // main has returned; exit somehow...        //
        if (!__scrt_is_managed_app())00A81E13  call        ___scrt_is_managed_app (0A81122h)  00A81E18  movzx       eax,al  00A81E1B  test        eax,eax  00A81E1D  jne         __scrt_common_main_seh+168h (0A81E28h)              exit(main_result);00A81E1F  mov         ecx,dword ptr [ebp-2Ch]  00A81E22  push        ecx  00A81E23  call        _exit (0A812CBh)  
        if (!has_cctor)00A81E28  movzx       edx,byte ptr [has_cctor]  00A81E2C  test        edx,edx  00A81E2E  jne         __scrt_common_main_seh+175h (0A81E35h)              _cexit();00A81E30  call        __cexit (0A810AAh)  
        // Finally, we terminate the CRT:        __scrt_uninitialize_crt(true, false);00A81E35  push        0  00A81E37  push        1  00A81E39  call        ___scrt_uninitialize_crt (0A8115Eh)  00A81E3E  add         esp,8          return main_result;00A81E41  mov         eax,dword ptr [ebp-2Ch]  00A81E44  mov         dword ptr [ebp-3Ch],eax  00A81E47  mov         dword ptr [ebp-4],0FFFFFFFEh  00A81E4E  mov         eax,dword ptr [ebp-3Ch]  00A81E51  jmp         $LN18+44h (0A81EBBh)      }00A81E53  mov         dword ptr [ebp-4],0FFFFFFFEh  00A81E5A  jmp         $LN18+44h (0A81EBBh)      __except (_seh_filter_exe(GetExceptionCode(), GetExceptionInformation()))00A81E5C  mov         ecx,dword ptr [ebp-14h]  00A81E5F  mov         edx,dword ptr [ecx]  00A81E61  mov         eax,dword ptr [edx]  00A81E63  mov         dword ptr [ebp-30h],eax  00A81E66  mov         ecx,dword ptr [ebp-14h]  00A81E69  push        ecx  00A81E6A  mov         edx,dword ptr [ebp-30h]  00A81E6D  push        edx  00A81E6E  call        __seh_filter_exe (0A8124Eh)  00A81E73  add         esp,8  $LN21:00A81E76  ret  $LN18:00A81E77  mov         esp,dword ptr [ebp-18h]      {        // Note:  We should never reach this except clause.        int const main_result = GetExceptionCode();00A81E7A  mov         eax,dword ptr [ebp-30h]  00A81E7D  mov         dword ptr [ebp-34h],eax  
        if (!__scrt_is_managed_app())00A81E80  call        ___scrt_is_managed_app (0A81122h)  00A81E85  movzx       ecx,al  00A81E88  test        ecx,ecx  00A81E8A  jne         $LN18+1Eh (0A81E95h)              _exit(main_result);00A81E8C  mov         edx,dword ptr [ebp-34h]  00A81E8F  push        edx  00A81E90  call        __exit (0A811B8h)  
        if (!has_cctor)00A81E95  movzx       eax,byte ptr [has_cctor]  
        if (!has_cctor)00A81E99  test        eax,eax  00A81E9B  jne         $LN18+2Bh (0A81EA2h)              _c_exit();00A81E9D  call        __c_exit (0A8132Ah)  
        return main_result;00A81EA2  mov         ecx,dword ptr [ebp-34h]  00A81EA5  mov         dword ptr [ebp-40h],ecx  00A81EA8  mov         dword ptr [ebp-4],0FFFFFFFEh  00A81EAF  mov         eax,dword ptr [ebp-40h]  00A81EB2  jmp         $LN18+44h (0A81EBBh)      }00A81EB4  mov         dword ptr [ebp-4],0FFFFFFFEh      }}00A81EBB  mov         ecx,dword ptr [ebp-10h]  00A81EBE  mov         dword ptr fs:[0],ecx  00A81EC5  pop         ecx  00A81EC6  pop         edi  00A81EC7  pop         esi  00A81EC8  pop         ebx  00A81EC9  mov         esp,ebp  00A81ECB  pop         ebp  00A81ECC  ret  --- No source file -------------------------------------------------------------00A81ECD  int         3  00A81ECE  int         3  00A81ECF  int         3  00A81ED0  int         3  00A81ED1  int         3  00A81ED2  int         3  00A81ED3  int         3  00A81ED4  int         3  00A81ED5  int         3  00A81ED6  int         3  00A81ED7  int         3  00A81ED8  int         3  00A81ED9  int         3  00A81EDA  int         3  00A81EDB  int         3  00A81EDC  int         3  00A81EDD  int         3  00A81EDE  int         3  00A81EDF  int         3  00A81EE0  int         3  00A81EE1  int         3  00A81EE2  int         3  00A81EE3  int         3  00A81EE4  int         3  00A81EE5  int         3  00A81EE6  int         3  00A81EE7  int         3  00A81EE8  int         3  00A81EE9  int         3  00A81EEA  int         3  00A81EEB  int         3  00A81EEC  int         3  00A81EED  int         3  00A81EEE  int         3  00A81EEF  int         3  00A81EF0  int         3  00A81EF1  int         3  00A81EF2  int         3  00A81EF3  int         3  00A81EF4  int         3  00A81EF5  int         3  00A81EF6  int         3  00A81EF7  int         3  00A81EF8  int         3  00A81EF9  int         3  00A81EFA  int         3  00A81EFB  int         3  00A81EFC  int         3  00A81EFD  int         3  00A81EFE  int         3  00A81EFF  int         3  00A81F00  int         3  00A81F01  int         3  00A81F02  int         3  00A81F03  int         3  00A81F04  int         3  00A81F05  int         3  00A81F06  int         3  00A81F07  int         3  00A81F08  int         3  00A81F09  int         3  00A81F0A  int         3  00A81F0B  int         3  00A81F0C  int         3  00A81F0D  int         3  00A81F0E  int         3  00A81F0F  int         3  00A81F10  int         3  00A81F11  int         3  00A81F12  int         3  00A81F13  int         3  00A81F14  int         3  00A81F15  int         3  00A81F16  int         3  00A81F17  int         3  00A81F18  int         3  00A81F19  int         3  00A81F1A  int         3  00A81F1B  int         3  00A81F1C  int         3  00A81F1D  int         3  00A81F1E  int         3  00A81F1F  int         3  00A81F20  int         3  00A81F21  int         3  00A81F22  int         3  00A81F23  int         3  00A81F24  int         3  00A81F25  int         3  00A81F26  int         3  00A81F27  int         3  00A81F28  int         3  00A81F29  int         3  00A81F2A  int         3  00A81F2B  int         3  00A81F2C  int         3  00A81F2D  int         3  00A81F2E  int         3  00A81F2F  int         3  00A81F30  int         3  00A81F31  int         3  00A81F32  int         3  00A81F33  int         3  00A81F34  int         3  00A81F35  int         3  00A81F36  int         3  00A81F37  int         3  00A81F38  int         3  00A81F39  int         3  00A81F3A  int         3  00A81F3B  int         3  00A81F3C  int         3  00A81F3D  int         3  00A81F3E  int         3  00A81F3F  int         3  00A81F40  int         3  00A81F41  int         3  00A81F42  int         3  00A81F43  int         3  00A81F44  int         3  00A81F45  int         3  00A81F46  int         3  00A81F47  int         3  00A81F48  int         3  00A81F49  int         3  00A81F4A  int         3  00A81F4B  int         3  00A81F4C  int         3  00A81F4D  int         3  00A81F4E  int         3  00A81F4F  int         3  --- f:\dd\vctools\crt\vcstartup\inc\vcstartup_internal.h -----------------------//// vcstartup_internal.h////      Copyright (c) Microsoft Corporation. All rights reserved.//// Declarations and utilities used by the statically-linked CRT startup code.//#pragma once
#include <corecrt_startup.h>#include <internal_shared.h>#include <intrin.h>#include <process.h>#include <vcruntime_startup.h>#include <windows.h>

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// EncodePointer and DecodePointer Redeclarations////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+// In the managed startup code, these functions must be re-declared with the// appropriate security attributes, othrewise calls to them will result in// System::Security::SecurityException exceptions being thrown._CRT_SUPPRESS_UNMANAGED_CODE_SECURITY_CRT_SECURITYCRITICAL_ATTRIBUTE_CRT_RELIABILITY_CONTRACT
#ifndef _ONECORE    _CRT_INTEROPSERVICES_DLLIMPORT("KERNEL32.dll", "EncodePointer", _CRT_CALLING_CONVENTION_WINAPI)#else  // _ONECORE    _CRT_INTEROPSERVICES_DLLIMPORT("API-MS-WIN-CORE-UTIL-L1-1-0.dll", "EncodePointer", _CRT_CALLING_CONVENTION_WINAPI)#endif // _ONECORE
WINBASEAPI _Ret_maybenull_ PVOID WINAPI EncodePointer(_In_opt_ PVOID _Ptr);
_CRT_SUPPRESS_UNMANAGED_CODE_SECURITY_CRT_SECURITYCRITICAL_ATTRIBUTE_CRT_RELIABILITY_CONTRACT
#ifndef _ONECORE    _CRT_INTEROPSERVICES_DLLIMPORT("KERNEL32.dll", "DecodePointer", _CRT_CALLING_CONVENTION_WINAPI)#else  // _ONECORE    _CRT_INTEROPSERVICES_DLLIMPORT("API-MS-WIN-CORE-UTIL-L1-1-0.dll", "DecodePointer", _CRT_CALLING_CONVENTION_WINAPI)#endif // _ONECORE
WINBASEAPI _Ret_maybenull_ PVOID WINAPI DecodePointer(_In_opt_ PVOID _Ptr);

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Utility Macros////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+// The _VCRT_DECLARE_ALTERNATE_NAME macro provides an architecture-neutral way// of specifying /alternatename comments to the linker.  It prepends the leading// underscore for x86 and leaves names unmodified for other architectures.#if defined _M_IX86    #define _VCRT_DECLARE_ALTERNATE_NAME_PREFIX "_"#elif defined _M_X64 || defined _M_ARM || defined _M_ARM64    #define _VCRT_DECLARE_ALTERNATE_NAME_PREFIX ""#else    #error Unsupported architecture#endif
#define _VCRT_DECLARE_ALTERNATE_NAME(name, alternate_name)  \    __pragma(comment(linker,                                \        "/alternatename:"                                   \        _VCRT_DECLARE_ALTERNATE_NAME_PREFIX #name           \        "="                                                 \        _VCRT_DECLARE_ALTERNATE_NAME_PREFIX #alternate_name \        ))
// The _VCRT_DEFINE_IAT_SYMBOL macro provides an architecture-neutral way of// defining IAT symbols (__imp_- or _imp__-prefixed symbols).#ifdef _M_IX86    #define _VCRT_DEFINE_IAT_SYMBOL_MAKE_NAME(f) _CRT_CONCATENATE(_imp__, f)#else    #define _VCRT_DEFINE_IAT_SYMBOL_MAKE_NAME(f) _CRT_CONCATENATE(__imp_, f)#endif
#define _VCRT_DEFINE_IAT_SYMBOL(f)                                                          \    extern "C" __declspec(selectany) void const* const _VCRT_DEFINE_IAT_SYMBOL_MAKE_NAME(f) \        = reinterpret_cast<void const*>(f)

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Client Entry Point Declarations////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+#ifndef _M_CEE
    extern "C" int __CRTDECL main(        _In_                     int    argc,        _In_reads_(argc) _Pre_z_ char** argv,        _In_z_                   char** envp        );
    extern "C" int __CRTDECL wmain(        _In_                     int       argc,        _In_reads_(argc) _Pre_z_ wchar_t** argv,        _In_z_                   wchar_t** envp        );
    extern "C" int WINAPI WinMain(        _In_     HINSTANCE hInstance,        _In_opt_ HINSTANCE hPrevInstance,        _In_     LPSTR     lpCmdLine,        _In_     int       nShowCmd        );
    extern "C" int WINAPI wWinMain(        _In_     HINSTANCE hInstance,        _In_opt_ HINSTANCE hPrevInstance,        _In_     LPWSTR    lpCmdLine,        _In_     int       nShowCmd        );
#endif
#ifdef MRTDLL
    extern "C" BOOL __clrcall DllMain(        _In_ HINSTANCE hInstance,        _In_ DWORD     fdwReason,        _In_ LPVOID    lpvReserved        );
#else
    extern "C" BOOL WINAPI DllMain(        _In_ HINSTANCE hInstance,        _In_ DWORD     fdwReason,        _In_ LPVOID    lpvReserved        );
#endif

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Types////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+typedef BOOL (WINAPI* __scrt_dllmain_type)(HINSTANCE, DWORD, LPVOID);
enum class __scrt_module_type{    dll,    exe};

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Startup State Machine and Managed/Native Startup Synchronization////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+#ifndef _M_CEE_PURE
    enum class __scrt_native_startup_state    {        uninitialized,        initializing,        initialized    };
    extern "C" extern __scrt_native_startup_state __scrt_current_native_startup_state;    extern "C" extern void*                       __scrt_native_startup_lock;    extern "C" extern unsigned int                __scrt_native_dllmain_reason;
    // When this module is executing its DllMain, the __scrt_native_dllmain_reason    // flag stores the 'reason' with which DllMain was called.  When this module    // is not executing its DllMain, the flag is set to this 'no reason' sentinel    // value.    #define NATIVE_DLLMAIN_REASON_NO_REASON UINT_MAX

    // Returns true if it is currently safe for managed code to execute in this    // module; false otherwise.    inline bool __scrt_is_safe_for_managed_code() throw()    {        switch (__scrt_native_dllmain_reason)        {        case DLL_PROCESS_ATTACH:        case DLL_PROCESS_DETACH:            return false;
        default:            return true;        }    }
#endif // _M_CEE_PURE

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// General Startup Utilities////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+extern "C" _crt_argv_mode __CRTDECL _get_startup_argv_mode();extern "C" int __CRTDECL _get_startup_commit_mode();extern "C" int __CRTDECL _get_startup_file_mode();extern "C" int __CRTDECL _get_startup_new_mode();extern "C" int __CRTDECL _get_startup_thread_locale_mode();
void __CRTDECL __scrt_initialize_type_info();void __CRTDECL __scrt_uninitialize_type_info();
extern "C" bool __CRTDECL _should_initialize_environment();extern "C" void __CRTDECL _initialize_default_precision();extern "C" void __CRTDECL _initialize_invalid_parameter_handler();extern "C" void __CRTDECL _initialize_denormal_control();
extern "C" void __CRTDECL __scrt_initialize_default_local_stdio_options();extern "C" bool __cdecl __scrt_is_nonwritable_in_current_image(void const* target);extern "C" int  __cdecl __scrt_is_user_matherr_present();extern "C" int  __cdecl __scrt_is_ucrt_dll_in_use();
extern "C" _tls_callback_type const* __cdecl __scrt_get_dyn_tls_init_callback();extern "C" _tls_callback_type const* __cdecl __scrt_get_dyn_tls_dtor_callback();
#ifdef _M_CEE_PURE    extern "C" void __clrcall __scrt_initialize_stdio_msvcrt_compatibility_mode();    extern "C" void __clrcall __scrt_initialize_legacy_stdio_wide_specifier_mode();    extern "C" void __clrcall __scrt_initialize_iso_stdio_wide_specifier_mode();#endif
extern "C" extern int __crtWinrtInitType;
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Static / Dynamic CRT Library Specific Functionality////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+// These functions have different implementations for the static CRT and the CRT// DLLs.  Startup and termination are subtly different between the two kinds of// CRTs.
// When the CRT DLL is used, we must synchronize access to the startup code path.// When all modules loaded in the process are native, there is no opportunity for// problems here.  Managed module startup may cause unexpected reentrancy into// the startup code path if something goes wrong.  These "locks" are used to// accurately test for those problems.extern "C" bool __cdecl __scrt_acquire_startup_lock();extern "C" void __cdecl __scrt_release_startup_lock(bool is_nested);
// These are called during startup and termination to initialize or uninitialize// the CRT.  When the CRT is statically linked, these actually perform complete// CRT initialization, calling into each part of the CRT initialize them.  When// the CRT DLLs are used, the CRT DLLs initialize themselves when they are loaded.// However, some initialization is still required, to bind the module-specific// VCRuntime DLL to the global AppCRT DLL.extern "C" bool __cdecl __scrt_initialize_crt(__scrt_module_type module_type);extern "C" bool __cdecl __scrt_uninitialize_crt(bool is_terminating, bool from_exit);
// When the CRT DLLs are used, special handling is required for the onexit table// to ensure that functions are called at the right time during exit (during// actual process termination for the EXE; during detach for DLLs).extern "C" bool __cdecl __scrt_initialize_onexit_tables(__scrt_module_type module_type);
// When the CRT is statically linked and an exception occurs in the client DllMain// during DLL_PROCESS_ATTACH, we must roll-back the static CRT initialization// before calling into the exception filter to ensure that the CRT is not left in// an unknown state.extern "C" int __cdecl __scrt_dllmain_exception_filter(    HINSTANCE           instance,    DWORD               reason,    LPVOID              reserved,    __scrt_dllmain_type  crt_dllmain,    unsigned long       exception_code_,    PEXCEPTION_POINTERS exception_info_    );
// When the CRT is statically linked, the CRT and client C termination is shared// (there is only one atexit vector and one set of terminators to be run), so the// DLL unload C uninitialization just calls the normal C termination code.  When// the CRT DLLs are used, DLL unload does not cause C termination; it only causes// execution of the onexit vector for the terminators in that DLL.extern "C" bool __cdecl __scrt_dllmain_before_initialize_c();extern "C" bool __cdecl __scrt_dllmain_after_initialize_c();extern "C" void __cdecl __scrt_dllmain_uninitialize_c();extern "C" void __cdecl __scrt_dllmain_uninitialize_critical();
// When the CRT is statically linked, the statically linked CRT startup entry// point (the "real" DllMain) must notify the statically linked CRT components of// the process and thread attach and detach notifications.  When the CRT DLLs are// used, each CRT DLL will receive its own attach and detach notifications.extern "C" bool __cdecl __scrt_dllmain_crt_thread_attach();extern "C" bool __cdecl __scrt_dllmain_crt_thread_detach();

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Desktop / Windows Store App Specific Functionality////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+// These parts of the startup routines have different implementations for Desktop// apps and Windows Store apps.  In some cases, this is because some functionality// applies only to one kind of app or the other.  In other cases, it is because we// must do different things in Windows Store apps, which may not work on downlevel// operating systems.
// Gets the current wShowWindow flag from the STARTUPINFO for this process, to// be passed to WinMain.  In a Windows Store app, this function always returns// zero, because the value is not required.extern "C" WORD __cdecl __scrt_get_show_window_mode();
// Tests whether the EXE for this process is a managed module.  In Windows Store// apps, this function always returns false, because we do not support C++/CLI// and we do not need to support the complex mixed managed/native startup use// cases for which this function is required.extern "C" bool __cdecl __scrt_is_managed_app();
// Initializes the Windows Runtime (via RoInitialize) in the calling thread.// In Windows Store apps, this is called during EXE startup.  In Desktop apps,// this function has no effect.extern "C" int  __cdecl __scrt_initialize_winrt();
// Initializes the unhandled exception filter.  In Desktop apps, this filter is// what calls std::terminate when a C++ exception goes unhandled.  In Windows// Store apps, this function has no effect (we cannot register an unhandled// exception filter in a Windows Store app, and in most cases exceptions are// caught at the ABI boundary and translated either into an HRESULT or a// __failfast).  This function is called during the initialization of each EXE// that uses this CRT.extern "C" void __cdecl __scrt_set_unhandled_exception_filter();
// In Windows Store apps, and on computers where __fastfail is supported, this// function invokes __fastfail.  Otherwise, this function resets the unhandled// exception filter and calls the default unhandled exception filter with a// noncontinuable exception, which is as close as we can get to __fastfail.extern "C" __declspec(noreturn) void __cdecl __scrt_fastfail(unsigned code);

//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Heap Support////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+void __CRTDECL __scrt_throw_std_bad_alloc();void __CRTDECL __scrt_throw_std_bad_array_new_length();
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Thread-safe local static initialization support (shared with the managed implementation)////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
extern "C" int _Init_global_epoch;extern "C" void __cdecl _Init_thread_lock();extern "C" void __cdecl _Init_thread_unlock();extern "C" bool __cdecl _Init_thread_wait(DWORD const timeout);extern "C" void __cdecl _Init_thread_notify();
//-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+//// Common argv initialization utilities////-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
struct __scrt_narrow_argv_policy{    static int configure_argv() throw() { return _configure_narrow_argv(_get_startup_argv_mode()); }00A81F50  push        ebp  00A81F51  mov         ebp,esp  00A81F53  call        __get_startup_argv_mode (0A81014h)  00A81F58  push        eax  00A81F59  call        __configure_narrow_argv (0A812D5h)  00A81F5E  add         esp,4  00A81F61  pop         ebp  00A81F62  ret  --- No source file -------------------------------------------------------------00A81F63  int         3  00A81F64  int         3  00A81F65  int         3  00A81F66  int         3  00A81F67  int         3  00A81F68  int         3  00A81F69  int         3  00A81F6A  int         3  00A81F6B  int         3  00A81F6C  int         3  00A81F6D  int         3  00A81F6E  int         3  00A81F6F  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------00A81F70  push        ebp  00A81F71  mov         ebp,esp  00A81F73  mov         eax,1  00A81F78  pop         ebp  00A81F79  ret  --- No source file -------------------------------------------------------------00A81F7A  int         3  00A81F7B  int         3  00A81F7C  int         3  00A81F7D  int         3  00A81F7E  int         3  00A81F7F  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------};
struct __scrt_winmain_policy{    static _crt_app_type get_app_type() throw() { return _crt_gui_app; }};
#if defined _SCRT_STARTUP_MAIN
    using main_policy = __scrt_main_policy;    using argv_policy = __scrt_narrow_argv_policy;
    static void __cdecl initialize_environment() throw()    {00A81F80  push        ebp  00A81F81  mov         ebp,esp          _initialize_narrow_environment();00A81F83  call        __initialize_narrow_environment (0A811EFh)      }00A81F88  pop         ebp  00A81F89  ret  --- No source file -------------------------------------------------------------00A81F8A  int         3  00A81F8B  int         3  00A81F8C  int         3  00A81F8D  int         3  00A81F8E  int         3  00A81F8F  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl ---------------------
    static int __cdecl invoke_main() throw()    {00A81F90  push        ebp  00A81F91  mov         ebp,esp          return main(__argc, __argv, _get_initial_narrow_environment());00A81F93  call        __get_initial_narrow_environment (0A81037h)  00A81F98  push        eax  00A81F99  call        ___p___argv (0A8126Ch)  00A81F9E  mov         eax,dword ptr [eax]  00A81FA0  push        eax  00A81FA1  call        ___p___argc (0A81267h)  00A81FA6  mov         ecx,dword ptr [eax]  00A81FA8  push        ecx  00A81FA9  call        _main (0A81299h)  00A81FAE  add         esp,0Ch      }00A81FB1  pop         ebp  00A81FB2  ret  --- No source file -------------------------------------------------------------00A81FB3  int         3  00A81FB4  int         3  00A81FB5  int         3  00A81FB6  int         3  00A81FB7  int         3  00A81FB8  int         3  00A81FB9  int         3  00A81FBA  int         3  00A81FBB  int         3  00A81FBC  int         3  00A81FBD  int         3  00A81FBE  int         3  00A81FBF  int         3  --- f:\dd\vctools\crt\vcstartup\src\startup\exe_main.cpp -----------------------//// exe_wwinmain.cpp////      Copyright (c) Microsoft Corporation. All rights reserved.//// The mainCRTStartup() entry point, linked into client executables that// uses main().//#define _SCRT_STARTUP_MAIN#include "exe_common.inl"

extern "C" int mainCRTStartup(){00A81FC0  push        ebp  00A81FC1  mov         ebp,esp      return __scrt_common_main();00A81FC3  call        __scrt_common_main (0A81CA0h)  }00A81FC8  pop         ebp  00A81FC9  ret  --- No source file -------------------------------------------------------------00A81FCA  int         3  00A81FCB  int         3  00A81FCC  int         3  00A81FCD  int         3  00A81FCE  int         3  00A81FCF  int         3  00A81FD0  push        ebp  00A81FD1  mov         ebp,esp  00A81FD3  push        0FFFFFFFEh  00A81FD5  push        0A88EB8h  00A81FDA  push        offset _except_handler4 (0A83890h)  00A81FDF  mov         eax,dword ptr fs:[00000000h]  00A81FE5  push        eax  00A81FE6  sub         esp,24h  00A81FE9  push        ebx  00A81FEA  push        esi  00A81FEB  push        edi  00A81FEC  mov         eax,dword ptr [__security_cookie (0A8A024h)]  00A81FF1  xor         dword ptr [ebp-8],eax  00A81FF4  xor         eax,ebp  00A81FF6  push        eax  00A81FF7  lea         eax,[ebp-10h]  00A81FFA  mov         dword ptr fs:[00000000h],eax  00A82000  mov         dword ptr [ebp-18h],esp  00A82003  mov         byte ptr [bDebuggerListening],0  00A82007  mov         dword ptr [info],1001h  00A8200E  mov         eax,dword ptr [dwLevelRequired]  00A82011  mov         dword ptr [ebp-30h],eax  00A82014  lea         eax,[bDebuggerListening]  00A82017  mov         dword ptr [ebp-2Ch],eax  00A8201A  mov         dword ptr [ebp-4],0  00A82021  lea         eax,[info]  00A82024  push        eax  00A82025  push        6  00A82027  push        0  00A82029  push        406D1388h  00A8202E  call        dword ptr [__imp__RaiseException@16 (0A8B000h)]  00A82034  jmp         $LN6+3h (0A8204Ch)  $LN11:00A82036  mov         eax,dword ptr [ebp-14h]  00A82039  mov         eax,dword ptr [eax]  00A8203B  xor         ecx,ecx  00A8203D  cmp         dword ptr [eax],406D1388h  00A82043  sete        cl  00A82046  mov         eax,ecx  $LN9:00A82048  ret  $LN6:00A82049  mov         esp,dword ptr [ebp-18h]  00A8204C  mov         dword ptr [ebp-4],0FFFFFFFEh  00A82053  movzx       eax,byte ptr [bDebuggerListening]  00A82057  mov         ecx,dword ptr [ebp-10h]  00A8205A  mov         dword ptr fs:[0],ecx  00A82061  pop         ecx  00A82062  pop         edi  00A82063  pop         esi  00A82064  pop         ebx  00A82065  mov         esp,ebp  
